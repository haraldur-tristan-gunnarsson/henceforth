\ this should be a comment
: ~					' ' , ' , , ;
: ~LIT					[ LITERAL LITERAL , ] ;
: ~,					[ LITERAL , , ] ;
: [LITERAL]				[ ~LIT , ] ;
: '[LITERAL]				[ ' [LITERAL] ] ;
: ~~ 					[ '[LITERAL] LITERAL , , ] ;
: ~~					[ ' ~LIT , ~, ] ;
: ~~~					[ ' ~LIT ~LIT ~, ~LIT , ~, ~LIT ~, ~, ] ;
: ~~					~ ' ~ LITERAL ~ LITERAL ~ , ~ , ~ LITERAL ~ , ~ , ;
: ,,					~ LITERAL ~ , ~ , ;
: ~~					~ ' ~ LITERAL ~ LITERAL ~ , ~ , ~ ,, ;
: ~~					[ ~LIT ~ ,, ] ;
: ~~					[ LITERAL LITERAL , ~ LITERAL , , ] ;
: ~~~					~ ' ~~ LITERAL ~~ LITERAL ~~ , ~~ LITERAL ~ , ~~ , ~~ LITERAL ~~ , ~~ , ;
: ~~					~ LITERAL ~ LITERAL ~ , ~ ~ ~ LITERAL ~ , ~ , ;
: ~~~					~~ LITERAL ~~ LITERAL ~~ , ~~ LITERAL ~ ~ ~~ , ~~ LITERAL ~~ , ~~ , ;
: char					[ BSW c@ ] ;
: [char]				[ char [LITERAL] ] ;
: (					[char] ) ~ SKIPBL ;
( as should this )

: see		( -- )			[ ' seext ] ;
: x.		( n -- )		[ (x.) NL ] ;
: [emit]	( - c - )		~ [char] ~~ emit ;
: (0x.)		( n -- )		[emit] 0 [emit] x ~ (x.) ;
: 0x.		( n -- )		[ (0x.) NL ] ;

: CELLS 	( n -- n )		[ CELL * ] ;
: CELL-		( n -- n )		[ CELL - ] ;
: CELL+ 	( n -- n )		[ CELL + ] ;
: 1+		( n -- n )		[ 1 + ] ;
: 1-		( n -- n )		[ 1 - ] ;

: (SKIPCELL) [ r> r> CELL+ >r >r ] ;
: LIT [ r@ @ (SKIPCELL) ] ;
: LIT, [ r@ @ , (SKIPCELL) ] ;
: ~~ [ LIT, LIT, ~ ] ;
: ~~~ [ LIT, LIT, LIT, LIT, LIT, LIT, ~ ] ;
: ~~ ~ LIT, ~ LIT, ~ ~ ;
: ~~~ ~~ LIT, ~~ LIT, ~~ LIT, ~ ~ ;
: ~~~~ ~~~ LIT, ~~~ LIT, ~~~ LIT, ~~ LIT, ~ ~ ;

: RDUP		( r:n -- r:n r:n )	[ r@ >r ] ;
: DUP		( n -- n n )		[ @r r> ] ;
: OVER		( n1 n2 -- n1 n2 n1 )	[ >r DUP r> SWAP ] ;
: 2DUP		( n1n2 -- n1n2 n1n2 )	[ OVER OVER ] ;
: TUCK		( n1 n2 -- n2 n1 n2 )	[ SWAP OVER ] ;
: BOOL		( n -- bool )		[ NOT NOT ] ;

: 'XADDR	( - "name" - addr )	[ ' XADDR ] ;
: JMP					[ r> @ >r RET ] ; \ jump no link
: JMPL		( similar to CALL )	[ r@ @ (SKIPCELL) >r RET ] ; \ jump with link
: ~JMP,		( addr -- )		~~ JMP ~ , ;
: GOTO		( - "name" - )		[ 'XADDR ~JMP, ] ;
: ~JMPL,	( addr -- )		~~ JMPL ~ , ;
: GOSUB		( addr -- )		[ 'XADDR ~JMPL, ] ;
: (JMPNZ)	( n raddr -- addr )	[ >r NOT DUP NOT ] \ nbool bool
					[ r@ @ BAND SWAP ] \ new? nbool
					[ r> CELL+ BAND + ] ; \ addr
: JMPNZ		( n -- )		[ r> (JMPNZ) >r RET ] ;
: JMPNZL	( similar to CALL )	[ r@ (JMPNZ) >r RET ] ;
: (JMPNZP)	( n raddr -- n addr )	[ >r DUP r> (JMPNZ) ] ;
: JMPNZP	( n -- n )		[ r> (JMPNZP) >r RET ] ; \ preserv
: JMPNZPL	( similar to CALL )	[ r@ (JMPNZP) >r RET ] ; \ preserv

: TEMPALLOT	( -- addr )		[ HERE CELL ALLOT ] ;
: ifd{		( -- addr )		~~ NOT ~~ JMPNZ ~ TEMPALLOT ;
: if{		( -- addr )		~~ DUP ~ ifd{ ;
: }if		( addr -- )		[ HERE SWAP ! ] ;
: }else{	( addr -- addr )	~ }if ~~ NOT ~ if{ ;
: }elsed{	( addr -- addr )	~ }if ~~ NOT ~ ifd{ ;
: infloop{	( -- addr )		~ HERE ;
: }infloop	( addr -- )		~ ~JMP, ;
: loop{		( -- addr )		~ HERE ;
: }loop{	( -- addr )		~ if{ ;
: }loopd{	( -- addr )		~ ifd{ ;
: }loop		( addr addr -- )	[ SWAP ~JMP, }if ] ;
: do{		( -- addr )		~ HERE ;
: }dod		( addr -- )		~~ JMPNZ ~ , ; \ [ LIT, JMPNZ , ]
: }do		( addr -- )		~~ DUP ~ }dod ;

: value		( n - "name" - )	[ : [LITERAL] ; ] ;
: var		( - "name" - )		[ HERE CELL ALLOT value ] ;
: >var		( n - "name" - )	[ HERE SWAP , value ] ;
: ielse{	( n -- NOTn )		[ NOT iif{ ] ;
: iifd{		( n -- )		[ iif{ DROP ] ;
: ielsed{	( n -- )		[ ielse{ DROP ] ;

DPTR @ >var DPTR_SAVED
PPTR @ >var PPTR_SAVED
: PTRSL		( addr addr -- )	[ @ SWAP ! ] ;
: DPTRS		( -- )			[ DPTR_SAVED DPTR PTRSL ] ;
: DPTRS		( -- )			[ DPTR @ DPTR_SAVED ! ] ;
: PPTRS		( -- )			[ PPTR @ PPTR_SAVED ! ] ;
: DPTRL		( -- )			[ DPTR_SAVED @ DPTR ! ] ;
: PPTRL		( -- )			[ PPTR_SAVED @ PPTR ! ] ;

0 BNOT value CELL_MAX
CELL_MAX DUP 2 / - value SIGNED_MIN
: =		( n n -- bool )		[ - NOT ] ;
: <>		( n n -- bool )		[ - BOOL ] ;

: c,		( c -- )		[ HERE 1 ALLOT c! ] ;
: ,"		( - "text" - )		loop{ [ CIN DUP ] [char] " ~ <>
					}loopd{ ~ c, }loop ~ DROP ;
: ,n"		( - "text" - )		[ ," 0 c, ] ;
: ,nh"		( - "text" - addr )	[ HERE ,n" ] ;
: ,h"		( - "text" - addr len )	[ HERE ," DUP HERE SWAP - ] ;

: TRIM		( addr -- )		[ DUP CPTR ! CEND @ PAGESIZE - <= ]
					ifd{ [ HERE M_SET_END ] }if
					loop{ [ HEAD @ HERE >= ] }loopd{
					[ HEAD @ @ HEAD ! ] }loop ;
: FORGET	( - "name" - )		[ 'XADDR TRIM ] ;
: deletion_mark	( - "name" - )		~ HERE ~ : ~ [LITERAL] ~~ TRIM ~ ; ;

: ."		( - "text" - )		[ HERE ,nh" n. TRIM ] ;
: aligned_,nh"	( - "text" - )		[ ,nh" DUP HERE SWAP - ]
					loop{ [ DUP CELL % ] }loopd{
					[ 0 c, 1+ ] }loop ~ DROP ;
: ~."		( - "text" - )		~~ JMP
					[ TEMPALLOT aligned_,nh" SWAP ]
					[ }if [LITERAL] ] ~~ n. ;


\ : LIT, ~." LIT," [ .s r@ .s @ ] ~." got addr" [ .s , .s ] ~." written, skipping" [ (SKIPCELL) .s ] ~." skipped" ;


,nh" ]]" value DELIM
: [[					[ BSW DUP DELIM CSTRCMP NOT ]
					ifd{ [ DROP RET ] }if
					[ DUP WORDSEARCH ]
					if{ [ LIT, LIT, , ] }elsed{
					[ LIT, LIT, LIT, LIT ]
					[ LIT, LIT, # , ] }if GOTO [[ ;
\ : ]] ;	\ instead of ANSI FORTH's >DOES


\ [ LIT, LIT, LIT, LIT LIT, LIT, # , ]
\ [ LIT, LIT LIT, val ]
\ [ LIT val ]

: DOES:		( addr -- )		[ : [LITERAL] ] ; \ value?
: PRINT:	( addr -- )		~ DOES: [[ n. RET ]] ~ ; ;

: message"	( - "text" "name" - )	[ ,nh" PRINT: ] ;

\ a do loop would be useful here TODO
: makestar 	( n - "name" - )	[ HERE SWAP 1+ ]
					loop{ ~ 1- }loop{
					[char] * ~ c, }loop 
					[ DROP 0 , PRINT: ] ;

: DOES>		( addr -- )		~ [LITERAL] ~~ JMP
					[ TEMPALLOT }if ; RDROP RET ] ;

\ need to write a DUMP word as soon as possible

: 'XNAME	( - "word" - )		[ ' XNAME ] ;

\ : actor"	( - "text" "name" - )	[ ,nh" DOES: HEAD XNAME DOES> ]
\					[ n. n. ] ;

: emit_xxd	( n -- )		[ 0x7f BAND DUP 0x20 <= ]
					ifd{ ~ DROP [char] . }if
					~ emit ;
: 2DROP		( n n -- )		[ DROP DROP ] ;
: emit_range	( a a -- )		~ SWAP do{
						[ DUP c@ emit_xxd ]
						[ 1+ 2DUP <> ]
					}dod ~ 2DROP ;
: >range	( a n -- a a )		[ OVER + ] ;
: BL		( -- )			[ 0x20 emit ] ;
: hex_xxd	( n -- )		[ DUP 16 / (x.) 15 BAND (x.) ] ; \ would be better with a right shift -- TODO: add shift primitives
: hex_range	( a a -- )		~ SWAP do{
						[ DUP c@ hex_xxd ]
						[ 1+ 2DUP <> ]
					}dod ~ 2DROP ;
: dump_cell	( addr -- )		[ DUP (0x.) ] [emit] :
					[ BL BL ]
					[ DUP CELL >range hex_range ]
					[ BL BL ] [emit] |
					[ DUP CELL >range emit_range ]
					[emit] | [ BL BL ]
					[ @ NAME_OUT NL ] ;
: align		( n n -- n )		[ 1- BNOT BAND ] ;
: align_up	( n n -- n )		[ @r 1- + r> align ] ;
: dump_range	( a a -- )		\ [ CELL align_up SWAP ] do{
					~ SWAP do{
						[ DUP dump_cell ]
						[ CELL+ 2DUP > ]
					}dod ~ 2DROP ;
: dump		( a n -- )		[ >range dump_range ] ;

\ how to find out width of terminal (number of columns) for nice output?
