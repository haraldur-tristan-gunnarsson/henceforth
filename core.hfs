\ this should be a comment
: ~		' ' , ' , , ;
: ~LIT		[ LITERAL LITERAL , ] ;
: ~,		[ LITERAL , , ] ;
: [LITERAL]	[ ~LIT , ] ;
: '[LITERAL]	[ ' [LITERAL] ] ;
: ~~ 		[ '[LITERAL] LITERAL , , ] ;
: ~~		[ ' ~LIT , ~, ] ;
: ~~~		[ ' ~LIT ~LIT ~, ~LIT , ~, ~LIT ~, ~, ] ;
: ~~		~ ' ~ LITERAL ~ LITERAL ~ , ~ , ~ LITERAL ~ , ~ , ;
: ,,		~ LITERAL ~ , ~ , ;
: ~~		~ ' ~ LITERAL ~ LITERAL ~ , ~ , ~ ,, ;
: ~~		[ ~LIT ~ ,, ] ;
: ~~		[ LITERAL LITERAL , ~ LITERAL , , ] ;
: ~~~		~ ' ~~ LITERAL ~~ LITERAL ~~ , ~~ LITERAL ~ , ~~ , ~~ LITERAL ~~ , ~~ , ;
: ~~		~ LITERAL ~ LITERAL ~ , ~ ~ ~ LITERAL ~ , ~ , ;
: ~~~		~~ LITERAL ~~ LITERAL ~~ , ~~ LITERAL ~ ~ ~~ , ~~ LITERAL ~~ , ~~ , ;
: char					[ BSW c@ ] ;
: [char]				[ char [LITERAL] ] ;
: (					[char] ) ~ SKIPBL ;
( as should this )

: see		( -- )			[ ' seext ] ;
: x.		( n -- )		[ (x.) NL ] ;
: [emit]	( - c - )		~ [char] ~~ emit ;
: (0x.)		( n -- )		[emit] 0 [emit] x ~ (x.) ;
: 0x.		( n -- )		[ (0x.) NL ] ;

: CELLS 	( n -- n )		[ CELL * ] ;
: CELL-		( n -- n )		[ CELL - ] ;
: CELL+ 	( n -- n )		[ CELL + ] ;
: 1+		( n -- n )		[ 1 + ] ;
: 1-		( n -- n )		[ 1 - ] ;

: (SKIPCELL)	[ r> r> CELL+ >r >r ] ;
: LIT		[ r@ @ (SKIPCELL) ] ;
: LIT,		[ r@ @ , (SKIPCELL) ] ;
: ~LIT,		[ LIT, LIT, ] ;
: ~~		[ ~LIT, ~ ] ;
: ~~LIT,	[ ~LIT, ~LIT, ] ;
: ~~~		[ ~~LIT, ~~ ] ;
: ~~~LIT,	[ ~~LIT, ~~LIT, ] ;
: ~~~~		[ ~~~LIT, ~~~ ] ;
: ~~~~LIT,	[ ~~~LIT, ~~~LIT, ] ;
: ~~~~~		[ ~~~~LIT, ~~~~ ] ; \ etc.. Which is the last useful one?
: ~~		[ ~LIT, ~ ] ;
: ~~~		[ ~~LIT, ~LIT, ~ ] ;
: ~~~~		[ ~~~LIT, ~~LIT, ~LIT, ~ ] ;
: ~~~~~		[ ~~~~LIT, ~~~LIT, ~~LIT, ~LIT, ~ ] ;
: ~~		[ LIT, LIT, ~ ] ;
: ~~~		[ LIT, LIT, LIT, LIT, LIT, LIT, ~ ] ;
: ~~		~ LIT, ~ LIT, ~ ~ ;
: ~~~		~~ LIT, ~~ LIT, ~~ LIT, ~ ~ ;
: ~~~~		~~~ LIT, ~~~ LIT, ~~~ LIT, ~~ LIT, ~ ~ ;
\ number of LIT,s before word finally executed: 2^N - 1, where N is number of deferments.
\                                   0, 1, 3,  7, 15, 31, 63 ...
\ number of LIT,s before ~: 2^N - 2 -- 2, 6, 14, 30, 62 ...

: RDUP		( r:n -- r:n r:n )	[ r@ >r ] ;
: DUP		( n -- n n )		[ @r r> ] ;
: OVER		( n1 n2 -- n1 n2 n1 )	[ >r DUP r> SWAP ] ;
: 2DUP		( n1n2 -- n1n2 n1n2 )	[ OVER OVER ] ;
: TUCK		( n1 n2 -- n2 n1 n2 )	[ SWAP OVER ] ;
: BOOL		( n -- bool )		[ NOT NOT ] ;

: 'XADDR	( - "name" - addr )	[ ' XADDR ] ;
: JMP					[ r> @ >r RET ] ; \ jump no link
: JMPL		( similar to CALL )	[ r@ @ (SKIPCELL) >r RET ] ; \ jump with link
: ~JMP,		( addr -- )		~~ JMP ~ , ;
: GOTO		( - "name" - )		[ 'XADDR ~JMP, ] ;
: ~JMPL,	( addr -- )		~~ JMPL ~ , ;
: GOSUB		( addr -- )		[ 'XADDR ~JMPL, ] ;
: (JMPNZ)	( n raddr -- addr )	[ >r NOT DUP NOT ] \ nbool bool
					[ r@ @ BAND SWAP ] \ new? nbool
					[ r> CELL+ BAND + ] ; \ addr
: JMPNZ		( n -- )		[ r> (JMPNZ) >r RET ] ;
: JMPNZL	( similar to CALL )	[ r@ (JMPNZ) >r RET ] ;
: (JMPNZP)	( n raddr -- n addr )	[ >r DUP r> (JMPNZ) ] ;
: JMPNZP	( n -- n )		[ r> (JMPNZP) >r RET ] ; \ preserv
: JMPNZPL	( similar to CALL )	[ r@ (JMPNZP) >r RET ] ; \ preserv

: TEMPALLOT	( -- addr )		[ HERE CELL ALLOT ] ;
: HEREALLOT	( addr -- )		[ HERE SWAP ! ] ;
: ifd{		( -- addr )		~~ NOT ~~ JMPNZ ~ TEMPALLOT ;
: if{		( -- addr )		~~ DUP ~ ifd{ ;
: }if		( addr -- )		~ HEREALLOT ;
: }else{	( addr -- addr )	~ }if ~~ NOT ~ if{ ;
: }elsed{	( addr -- addr )	~ }if ~~ NOT ~ ifd{ ;
: infloop{	( -- addr )		~ HERE ;
: }infloop	( addr -- )		~ ~JMP, ;
: loop{		( -- addr )		~ HERE ;
: }loop{	( -- addr )		~ if{ ;
: }loopd{	( -- addr )		~ ifd{ ;
: }loop		( addr addr -- )	[ SWAP ~JMP, }if ] ;
: do{		( -- addr )		~ HERE ;
: }dod		( addr -- )		~~ JMPNZ ~ , ; \ [ LIT, JMPNZ , ]
: }do		( addr -- )		~~ DUP ~ }dod ;

: value		( n - "name" - )	[ : [LITERAL] ; ] ;
: var		( - "name" - )		[ HERE CELL ALLOT value ] ;
: >var		( n - "name" - )	[ HERE SWAP , value ] ;
: ielse{	( n -- NOTn )		[ NOT iif{ ] ;
: iifd{		( n -- )		[ iif{ DROP ] ;
: ielsed{	( n -- )		[ ielse{ DROP ] ;

0 BNOT value CELL_MAX
CELL_MAX DUP 2 / - value SIGNED_MIN
: =		( n n -- bool )		[ - NOT ] ;
: <>		( n n -- bool )		[ - BOOL ] ;

: c,		( c -- )		[ HERE 1 ALLOT c! ] ;
: ,"		( - "text" - )		loop{ [ CIN DUP ] [char] " ~ <>
					}loopd{ ~ c, }loop ~ DROP ;
: ,n"		( - "text" - )		[ ," 0 c, ] ;
: ,nh"		( - "text" - addr )	[ HERE ,n" ] ;
: ,h"		( - "text" - addr len )	[ HERE ," DUP HERE SWAP - ] ;

: TRIM		( addr -- )		[ DUP CPTR ! CEND @ PAGESIZE - <= ]
					ifd{ [ HERE M_SET_END ] }if
					loop{ [ HEAD @ HERE >= ] }loopd{
					[ HEAD @ @ HEAD ! ] }loop ;
: FORGET	( - "name" - )		[ 'XADDR TRIM ] ;
: deletion_mark	( - "name" - )		~ HERE ~ : ~ [LITERAL] ~~ TRIM ~ ; ;

: ."		( - "text" - )		[ HERE ,nh" n. TRIM ] ;
: aligned_,nh"	( - "text" - )		[ ,nh" DUP HERE SWAP - ]
					loop{ [ DUP CELL % ] }loopd{
					[ 0 c, 1+ ] }loop ~ DROP ;
: ~."		( - "text" - )		~~ JMP
					[ TEMPALLOT aligned_,nh" SWAP ]
					[ HEREALLOT [LITERAL] ] ~~ n. ;


\ : LIT, ~." LIT," [ .s r@ .s @ ] ~." got addr" [ .s , .s ] ~." written, skipping" [ (SKIPCELL) .s ] ~." skipped" ;


,nh" ]]" value DELIM
: [[					[ BSW DUP DELIM CSTRCMP NOT ]
					ifd{ [ DROP RET ] }if
					[ DUP WORDSEARCH ]
					if{ [ LIT, LIT, , ] }elsed{
					[ LIT, LIT, LIT, LIT ]
					[ LIT, LIT, # , ] }if GOTO [[ ;
\ : ]] ;	\ instead of ANSI FORTH's >DOES


\ [ LIT, LIT, LIT, LIT LIT, LIT, # , ]
\ [ LIT, LIT LIT, val ]
\ [ LIT val ]

: DOES:		( addr -- )		[ : [LITERAL] ] ; \ value?
: PRINT:	( addr -- )		~ DOES: [[ n. RET ]] ~ ; ;

: message"	( - "text" "name" - )	[ ,nh" PRINT: ] ;

\ a do loop would be useful here TODO
: makestar 	( n - "name" - )	[ HERE SWAP 1+ ]
					loop{ ~ 1- }loop{
					[char] * ~ c, }loop 
					[ DROP 0 , PRINT: ] ;

: LIT,,		[ LIT, LIT, ] GOTO LIT, ;
: LIT,,,	[ LIT,, LIT, ] GOTO LIT,, ;
: LIT,,,,	[ LIT,, LIT,, ] GOTO LIT,, ;

: (DOES>)	( addr -- )		~~~ JMP [ LIT, LIT, TEMPALLOT ]
					[[ ; RET ]] ~ HEREALLOT ;
: (DOES>)	( addr -- )		~~~ JMP ~~ LIT, ~ TEMPALLOT
					~~ ; ~~ RET     ~ HEREALLOT ;
: (DOES>)	( addr -- )		[ LIT, LIT, LIT, JMP ]
					[ LIT, LIT,       TEMPALLOT ]
					[ LIT, ; LIT, RET HEREALLOT ] ;
: (DOES>)	( addr -- )		[ LIT,, JMP ~LIT, TEMPALLOT ]
					[ LIT, ; LIT, RET HEREALLOT ] ;
: DOES>		( addr -- )		~~ [LITERAL] ~ (DOES>) ;

: 'XNAME	( - "word" - addr )	[ ' XNAME ] ;


: emit_xxd	( n -- )		[ 0x7f BAND DUP 0x20 <= ]
					ifd{ ~ DROP [char] . }if
					~ emit ;
: 2DROP		( n n -- )		[ DROP DROP ] ;
: emit_range	( a a -- )		~ SWAP do{
						[ DUP c@ emit_xxd ]
						[ 1+ 2DUP <> ]
					}dod ~ 2DROP ;
\ if making a general emit_range, may want an "UNLINK" word to remove the latest version of a named ("UNLINK emit_range", for example) word from the dictionary, to restore and previously existing version
: >range	( a n -- a a )		[ OVER + ] ;
: BL		( -- )			[ 0x20 emit ] ;
: hex_xxd	( n -- )		[ DUP 16 / (x.) 15 BAND (x.) ] ; \ would be better with a right shift -- TODO: add shift primitives
: hex_range	( a a -- )		~ SWAP do{
						[ DUP c@ hex_xxd ]
						[ 1+ 2DUP <> ]
					}dod ~ 2DROP ;
: dump_cell	( addr -- )		[ DUP (0x.) ] [emit] :
					[ BL BL ]
					[ DUP CELL >range hex_range ]
					[ BL BL ] [emit] |
					[ DUP CELL >range emit_range ]
					[emit] | [ BL BL ]
					[ @ NAME_OUT NL ] ;
: align		( n n -- n )		[ 1- BNOT BAND ] ;
: align_up	( n n -- n )		[ @r 1- + r> align ] ;
: dump_range	( a a -- )		\ [ CELL align_up SWAP ] do{
					~ SWAP do{
						[ DUP dump_cell ]
						[ CELL+ 2DUP > ]
					}dod ~ 2DROP ;
: dump		( a n -- )		[ >range dump_range ] ;

\ how to find out width of terminal (number of columns) for nice output?
