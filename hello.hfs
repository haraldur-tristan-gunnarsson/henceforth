." >>>>>>>>>>>>>>>>>>>>>>>>Hello, world!<<<<<<<<<<<<<<<<<<<"

." Note that HERE is:" HERE .

deletion_mark hello_mark

,nh" This text is stored semi-permanently, subject to a deletion_mark" n.
." The deletion_mark is called hello_mark."

." There is a procedure called test_proc."
,nh" This text is used in test_proc." : test_proc [LITERAL] ~ n. ;
." Calling test_proc..." test_proc
." Here is the list of all procedures (words) via WORDS:" WORDS
IDEBUG
." HERE is currently:" HERE .

IDEBUG

." Now using deletion_mark hello_mark." hello_mark
." Now HERE is:" HERE .
." And there are fewer WORDS:" WORDS

message"
 *** 
 * * 
 *** " box
." here is a box:" box

message"
  *  
 *** 
*****" triangle
." here is a triangle:" triangle

: house [ triangle box ] ;
." here is a house:" house

deletion_mark fizzbuzz_marker

\ local variables would be very nice for this! (base pointer needed?)
\ just having a base pointer, without variable names, would be useful...
\ perhaps, a separate stack just to manage such things? optional
\ maybe have a temporary "alias" dictionary as well, to give meaningful names for local variables -- this could be coded within this language!
: fizzbuzz	( n -- )	[ 0 ] loop{ [ 1+ 2DUP >= ] ( n c p )
				}loopd{ [ -1 >r ] ( n c )
					[ DUP 3 % NOT ] ifd{
						~." Fizz" [ RDROP 0 >r ]
					}if
					[ DUP 5 % NOT ] ifd{
						~." Buzz" [ RDROP 0 >r ]
					}if
					~ r> ifd{ [ DUP . ] }if
				}loop [ DROP DROP ] ;

."

commencing fizzbuzz to 15:" 15 fizzbuzz
see fizzbuzz_marker
fizzbuzz_marker
: fizz		( n -- bool )		[ 3 % NOT ] if{	~." Fizz" }if ;
: buzz		( n -- bool )		[ 5 % NOT ] if{	~." Buzz" }if ;
: fizzbuzz	( n -- )	[ 0 ] loop{ [ 1+ 2DUP >= ] ( n c p )
				}loopd{ [ 0 ] ( n c p )
					[ >r DUP fizz r> BOR ]
					[ >r DUP buzz r> BOR ]
					[ NOT ] ifd{ [ DUP . ] }if
				}loop [ DROP DROP ] ;

."

commencing fizzbuzz to 15:" 15 fizzbuzz
: fizzbuzz	( n -- )	[ 0 ] loop{ [ 1+ 2DUP >= ] ( n c p )
				}loopd{ [ 0 ] ( n c p )
					[ OVER fizz BOR ]
					[ OVER buzz BOR ]
					[ NOT ] ifd{ [ DUP . ] }if
				}loop [ DROP DROP ] ;

."


commencing fizzbuzz to 15:" 15 fizzbuzz
\ HERE value fizz 3 ,  ,n" Fizz"
\ HERE value buzz 5 ,  ,n" Buzz"
\ HERE value gizz 7 ,  ,n" Gizz"
\ HERE value cuzz 11 , ,n" Cuzz"	\ any more complex, would want a map
\ : test	( n a -- bool )	[ TUCK @ % NOT ] if{ [ SWAP CELL+ n. ] }if ;
\ : fizzbuzz	( n -- )	[ 0 ] loop{ [ 1+ 2DUP >= ] ( n c p )
\ 				}loopd{ [ 0 ] ( n c p )
\ 					[ OVER fizz test BOR ]
\ 					[ OVER buzz test BOR ]
\ 					[ OVER gizz test BOR ]
\ 					[ OVER cuzz test BOR ]
\ 					[ NOT ] ifd{ [ DUP . ] }if
\ 				}loop [ DROP DROP ] ;
\ 
\ ."
\ 
\ commencing fizzbuzz to 15:" 15 fizzbuzz

\ 3 value Fizz
\ 5 value Buzz
